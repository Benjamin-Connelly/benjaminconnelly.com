<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mirrorball</title>
<style>
  body { margin: 0; background: #000; overflow: hidden; cursor: none; }
  canvas { display: block; }
  .info { position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%);
    color: rgba(255,255,255,0.35); font: 12px/1 monospace; pointer-events: none; }
  .paused { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
    color: rgba(255,255,255,0.25); font: bold 32px/1 monospace; pointer-events: none;
    display: none; letter-spacing: 0.3em; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="paused" id="pauseLabel">PAUSED</div>
<div class="info">scroll: speed &middot; click: pause</div>
<script>
// ── Tweakable Constants ──────────────────────────────────────────────────────
const ROTATION_RPM      = 2.0;    // Ball spin speed (RPM)
const INTENSITY         = 1.3;    // Global brightness multiplier
const FACET_ROWS        = 22;     // Mirror rows pole-to-pole
const FACETS_AT_EQUATOR = 32;     // Tiles at widest row
const DOT_RADIUS        = 2.4;    // Base dot size (px at 900px viewport)
const DOT_SHARPNESS     = 0.8;    // 0 = soft gaussian, 1 = crisp
const SHIMMER           = 0.35;   // Twinkle intensity
const SHIMMER_SPEED     = 3.0;    // Twinkle oscillation rate (Hz)
const BEAM_OPACITY      = 0.06;   // Volumetric ray visibility
const BEAM_COUNT        = 12;     // Number of light rays
const GLOW_STRENGTH     = 0.35;   // Center ball glow intensity
const LIGHT_SMOOTHING   = 0.08;   // Mouse-to-light response lag (0–1)
const LIGHT_R = 255, LIGHT_G = 30, LIGHT_B = 20; // Pinspot color

// ── Canvas Setup ─────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, scale;

function resize() {
  const dpr = Math.min(devicePixelRatio || 1, 2);
  W = innerWidth; H = innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  scale = H / 900;
}
resize();
addEventListener('resize', resize);

// ── Facet Generation ─────────────────────────────────────────────────────────
// Spherical coords, brick-lay stagger, proportional columns per row
const facets = [];
for (let row = 0; row < FACET_ROWS; row++) {
  const phi = Math.PI * (0.06 + 0.88 * (row + 0.5) / FACET_ROWS);
  const sinPhi = Math.sin(phi);
  const cols = Math.max(4, Math.round(FACETS_AT_EQUATOR * sinPhi));
  const stagger = (row & 1) * 0.5 / cols;
  for (let col = 0; col < cols; col++) {
    facets.push({
      theta: 2 * Math.PI * (col / cols + stagger),
      phi,
      phase: Math.random() * Math.PI * 2,
      size: 0.7 + Math.random() * 0.6
    });
  }
}

// ── State ────────────────────────────────────────────────────────────────────
let rpm = ROTATION_RPM;
let paused = false;
let rotation = 0;
let lastTime = 0;
let mouseX = 0, mouseY = 0, mouseActive = false;

// Smoothed and target light direction
let lx = 0, ly = -0.5, lz = 0.6;
let tlx = 0, tly = -0.5, tlz = 0.6;

// Reusable vectors (Float64Array for precision)
const N = new Float64Array(3);
const L = new Float64Array(3);
const R = new Float64Array(3);

// ── Interaction ──────────────────────────────────────────────────────────────
addEventListener('mousemove', e => {
  mouseX = e.clientX; mouseY = e.clientY; mouseActive = true;
  tlx = (e.clientX / W) * 2 - 1;
  tly = -((e.clientY / H) * 2 - 1);
  tlz = 0.6;
});
addEventListener('touchmove', e => {
  e.preventDefault();
  const t = e.touches[0];
  mouseX = t.clientX; mouseY = t.clientY; mouseActive = true;
  tlx = (t.clientX / W) * 2 - 1;
  tly = -((t.clientY / H) * 2 - 1);
  tlz = 0.6;
}, { passive: false });
addEventListener('wheel', e => {
  rpm = Math.max(0.1, Math.min(8.0, rpm + e.deltaY * 0.002));
});
addEventListener('click', () => {
  paused = !paused;
  document.getElementById('pauseLabel').style.display = paused ? 'block' : 'none';
});

// ── Render Loop ──────────────────────────────────────────────────────────────
function frame(time) {
  requestAnimationFrame(frame);
  const dt = lastTime ? (time - lastTime) / 1000 : 0;
  lastTime = time;
  if (!paused) rotation += rpm * (2 * Math.PI / 60) * dt;

  // Smooth light direction toward target
  lx += (tlx - lx) * LIGHT_SMOOTHING;
  ly += (tly - ly) * LIGHT_SMOOTHING;
  lz += (tlz - lz) * LIGHT_SMOOTHING;
  const lLen = Math.sqrt(lx * lx + ly * ly + lz * lz);
  L[0] = lx / lLen; L[1] = ly / lLen; L[2] = lz / lLen;

  const cx = W / 2, cy = H / 2;
  const t = time * 0.001;

  // ── Layer 1: Background ────────────────────────────────────────────────────
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = 'rgb(2,1,5)';
  ctx.fillRect(0, 0, W, H);

  // ── Layer 2: Cursor glow (spotlight source) ────────────────────────────────
  if (mouseActive) {
    const r = 180 * scale;
    const cg = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, r);
    cg.addColorStop(0, `rgba(${LIGHT_R},${LIGHT_G},${LIGHT_B},0.10)`);
    cg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = cg;
    ctx.fillRect(mouseX - r, mouseY - r, r * 2, r * 2);
  }

  // ── Layer 3: Center glow (ambient scatter from ball body) ──────────────────
  const gr = 350 * scale;
  const gg = ctx.createRadialGradient(cx, cy, 0, cx, cy, gr);
  gg.addColorStop(0, `rgba(${LIGHT_R},${LIGHT_G},${LIGHT_B},${(0.08 * GLOW_STRENGTH).toFixed(3)})`);
  gg.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = gg;
  ctx.fillRect(cx - gr, cy - gr, gr * 2, gr * 2);

  // ── Layer 4: Volumetric beams ──────────────────────────────────────────────
  ctx.globalCompositeOperation = 'lighter';
  const beamLen = Math.max(W, H) * 0.9;
  for (let i = 0; i < BEAM_COUNT; i++) {
    const base = (i / BEAM_COUNT) * Math.PI * 2 + rotation * 0.5;
    const wobble = Math.sin(t + i * 2.1) * 0.04;
    const angle = base + wobble;
    const spread = 0.035;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(angle - spread) * beamLen, cy + Math.sin(angle - spread) * beamLen);
    ctx.lineTo(cx + Math.cos(angle + spread) * beamLen, cy + Math.sin(angle + spread) * beamLen);
    ctx.closePath();
    const bg = ctx.createLinearGradient(cx, cy,
      cx + Math.cos(angle) * beamLen, cy + Math.sin(angle) * beamLen);
    bg.addColorStop(0, `rgba(${LIGHT_R},${LIGHT_G},${LIGHT_B},${BEAM_OPACITY})`);
    bg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = bg;
    ctx.fill();
  }

  // ── Layer 5: Reflected light dots ──────────────────────────────────────────
  for (let i = 0; i < facets.length; i++) {
    const f = facets[i];
    const theta = f.theta + rotation;
    const sinPhi = Math.sin(f.phi), cosPhi = Math.cos(f.phi);

    // Facet normal (Y-axis rotation baked into theta)
    N[0] = sinPhi * Math.cos(theta);
    N[1] = cosPhi;
    N[2] = sinPhi * Math.sin(theta);

    // Shimmer: sinusoidal perturbation to normal (micro-vibration / surface imperfection)
    const sh = SHIMMER * Math.sin(t * SHIMMER_SPEED + f.phase);
    N[0] += sh * 0.03 * Math.sin(f.phase + t * 1.7);
    N[1] += sh * 0.03 * Math.cos(f.phase + t * 2.3);
    N[2] += sh * 0.03 * Math.sin(f.phase * 1.3 + t * 1.1);
    const nLen = Math.sqrt(N[0] * N[0] + N[1] * N[1] + N[2] * N[2]);
    N[0] /= nLen; N[1] /= nLen; N[2] /= nLen;

    // Back-face culling: skip facets not facing the light
    const NdotNegL = -(N[0] * L[0] + N[1] * L[1] + N[2] * L[2]);
    if (NdotNegL < 0.01) continue;

    // Reflection: R = L - 2(L·N)N
    const LdotN = L[0] * N[0] + L[1] * N[1] + L[2] * N[2];
    R[0] = L[0] - 2 * LdotN * N[0];
    R[1] = L[1] - 2 * LdotN * N[1];
    R[2] = L[2] - 2 * LdotN * N[2];

    // Spherical unwrap → screen coords
    const az = Math.atan2(R[2], R[0]);
    const el = Math.asin(Math.max(-1, Math.min(1, R[1])));
    const sx = cx + (az / Math.PI) * cx;
    const sy = cy - (el / (Math.PI * 0.5)) * cy;

    // Specular falloff
    const brightness = Math.pow(NdotNegL, 1.7) * INTENSITY;

    // Color: bloom bright dots toward white (overexposure simulation)
    const bloom = Math.min(1, brightness);
    const cr = LIGHT_R + (255 - LIGHT_R) * bloom;
    const cg = LIGHT_G + (255 - LIGHT_G) * bloom;
    const cb = LIGHT_B + (255 - LIGHT_B) * bloom;

    const baseR = DOT_RADIUS * scale * f.size;
    const coreR = Math.max(0.5, baseR * (0.3 + 0.7 * brightness));
    const haloR = coreR * (2.5 + 2.5 * (1 - DOT_SHARPNESS));

    // Outer halo
    if (haloR > 0.5) {
      const haloA = Math.min(1, 0.2 * brightness);
      const hg = ctx.createRadialGradient(sx, sy, 0, sx, sy, haloR);
      hg.addColorStop(0, `rgba(${cr|0},${cg|0},${cb|0},${haloA.toFixed(3)})`);
      hg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = hg;
      ctx.beginPath();
      ctx.arc(sx, sy, haloR, 0, Math.PI * 2);
      ctx.fill();
    }

    // Crisp bright core
    ctx.fillStyle = `rgba(${cr|0},${cg|0},${cb|0},${Math.min(1, brightness * 0.9).toFixed(3)})`;
    ctx.beginPath();
    ctx.arc(sx, sy, coreR, 0, Math.PI * 2);
    ctx.fill();
  }

  // Reset compositing
  ctx.globalCompositeOperation = 'source-over';
}
requestAnimationFrame(frame);
</script>
</body>
</html>
