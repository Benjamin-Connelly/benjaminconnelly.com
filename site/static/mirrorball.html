<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mirrorball</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" crossorigin="anonymous">
<style>
  body { margin: 0; background: #000; overflow: hidden; cursor: none; }
  canvas { display: block; }
  .paused { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
    color: rgba(255,255,255,0.25); font: bold 32px/1 monospace; pointer-events: none;
    display: none; letter-spacing: 0.3em; }

  /* Help pill */
  #help-pill {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.12);
    border-radius: 24px; padding: 10px 22px;
    font: 13px/1.6 -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    color: rgba(255,255,255,0.75); white-space: nowrap;
    pointer-events: none; z-index: 10;
    animation: fadeIn 1.2s ease-out;
    transition: opacity 0.3s ease;
  }
  @supports (backdrop-filter: blur(12px)) {
    #help-pill { backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      background: rgba(0,0,0,0.35); }
  }
  #help-pill.hidden { opacity: 0; pointer-events: none; }
  .touch-help { display: none; }
  @media (pointer: coarse) { .desktop-help { display: none; } .touch-help { display: inline; } }
  #help-pill span { opacity: 0.45; margin: 0 6px; }
  #help-pill kbd { font: inherit; background: rgba(255,255,255,0.1);
    border-radius: 4px; padding: 1px 6px; margin: 0 1px; }
  @keyframes fadeIn { from { opacity: 0; transform: translateX(-50%) translateY(12px); }
    to { opacity: 1; transform: translateX(-50%) translateY(0); } }

  /* Modal */
  #modal-backdrop {
    position: fixed; inset: 0; background: rgba(0,0,0,0.85);
    z-index: 100; display: none; align-items: center; justify-content: center;
    cursor: auto;
  }
  @supports (backdrop-filter: blur(4px)) {
    #modal-backdrop { backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
  }
  #modal-backdrop.open { display: flex; }
  #modal-panel {
    background: rgba(20,18,28,0.95); border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px; max-width: 680px; width: 92%; max-height: 85vh;
    box-shadow: 0 24px 80px rgba(0,0,0,0.6); display: flex; flex-direction: column;
    position: relative;
  }
  #modal-panel .close {
    position: absolute; top: 12px; right: 16px; background: none; border: none;
    color: rgba(255,255,255,0.5); font-size: 22px; cursor: pointer; padding: 4px 8px;
    line-height: 1; z-index: 1;
  }
  #modal-panel .close:hover { color: #fff; }
  #modal-panel h2 {
    font: 600 22px/1.3 -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    color: #fff; margin: 0; padding: 28px 32px 0;
  }
  .modal-body {
    padding: 20px 32px 28px; overflow-y: auto; max-height: 70vh;
    font: 15px/1.7 -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    color: rgba(255,255,255,0.8);
  }
  .modal-body h3 { color: #fff; font-size: 16px; margin: 24px 0 8px; }
  .modal-body h3:first-child { margin-top: 0; }
  .modal-body p { margin: 0 0 12px; }
  .modal-body em { color: rgba(255,255,255,0.55); font-style: italic; }
  .modal-body ul { margin: 8px 0 12px; padding-left: 24px; }
  .modal-body li { margin: 4px 0; }
  .modal-body code { background: rgba(255,255,255,0.08); border-radius: 3px;
    padding: 1px 5px; font-family: 'SF Mono', 'Fira Code', monospace; font-size: 13px; }
  .modal-body .katex-display { margin: 16px 0; }
  .modal-body .katex { color: rgba(255,255,255,0.85); font-size: 1.1em; }
  /* Custom scrollbar */
  .modal-body::-webkit-scrollbar { width: 6px; }
  .modal-body::-webkit-scrollbar-track { background: transparent; }
  .modal-body::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 3px; }

  @media (max-width: 640px) {
    #modal-panel { width: 100%; max-width: none; margin: 8px; border-radius: 12px; }
    .modal-body { padding: 16px 20px 24px; }
    #modal-panel h2 { padding: 24px 20px 0; font-size: 19px; }
    #help-pill { font-size: 11px; padding: 8px 16px; }
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="paused" id="pauseLabel">PAUSED</div>
<div id="help-pill">
  <span class="desktop-help">
    <kbd>hjkl</kbd> light <span>&middot;</span>
    <kbd>&larr;&rarr;</kbd> speed <span>&middot;</span>
    <kbd>Space</kbd> pause <span>&middot;</span>
    <kbd>?</kbd> help <span>&middot;</span>
    <kbd>M</kbd> physics
  </span>
  <span class="touch-help">
    1 finger: light <span>&middot;</span>
    2 fingers: speed <span>&middot;</span>
    tap: pause
  </span>
</div>

<div id="modal-backdrop" role="dialog" aria-modal="true" aria-labelledby="modal-title">
  <div id="modal-panel">
    <button class="close" aria-label="Close">&times;</button>
    <h2 id="modal-title">The Physics of a Mirror Ball</h2>
    <div class="modal-body">
      <p>A mirror ball is an elegant demonstration of the law of reflection applied across hundreds of tiny mirrors arranged on a sphere. What appears as magical scattered light is actually straightforward geometric optics — each dot on the wall is a real image of the spotlight, reflected by one facet.</p>

      <h3>1. Facets as Tiny Plane Mirrors</h3>
      <p>A standard mirror ball is covered with small, flat, square mirrors — typically 1–2 cm on a side — glued to a spherical shell. Each mirror tile is a plane mirror whose normal vector \(\hat{n}\) points radially outward from the sphere's center. Because the sphere has curvature, adjacent facets point in slightly different directions, which is exactly why the reflected beams spread out across the room instead of all converging at one point.</p>
      <p>The key insight: <strong>the ball is not a curved mirror</strong>. It's a <em>piecewise-planar</em> mirror. Each facet reflects independently according to the law of reflection, and the spherical arrangement simply provides a convenient way to sample many different normal directions.</p>

      <h3>2. The Law of Reflection</h3>
      <p>For a single facet with unit normal \(\hat{n}\), incoming light direction \(\hat{L}\) (pointing <em>toward</em> the facet), the reflected ray direction is:</p>
      $$\hat{R} = \hat{L} - 2(\hat{L} \cdot \hat{n})\hat{n}$$
      <p>This is the vector form of "angle of incidence equals angle of reflection." The reflected ray \(\hat{R}\) lies in the plane defined by \(\hat{L}\) and \(\hat{n}\), and makes equal angles with \(\hat{n}\) on opposite sides.</p>
      <p>In the simulation, we compute this for every facet on every frame. The incoming light direction \(\hat{L}\) comes from the spotlight (controlled by mouse position), and \(\hat{n}\) comes from the facet's position on the sphere (modified by rotation).</p>

      <h3>3. Why the Dots Move</h3>
      <p>As the ball rotates, each facet's normal vector \(\hat{n}\) changes direction in world space. If the ball rotates by angle \(\theta\) about the vertical axis, a facet at spherical coordinates \((\phi, \theta_0)\) has its azimuthal angle shifted to \(\theta_0 + \theta\). The normal becomes:</p>
      $$\hat{n} = (\sin\phi\cos(\theta_0 + \theta),\; \cos\phi,\; \sin\phi\sin(\theta_0 + \theta))$$
      <p>Since \(\hat{R}\) depends on \(\hat{n}\), the reflected beam sweeps across the room as the ball turns. Each facet traces out its own arc on the walls and ceiling, and with hundreds of facets all at different latitudes and longitudes, the result is a complex, interlocking pattern of moving dots.</p>

      <h3>4. The 2× Angular Amplification</h3>
      <p>One of the most important properties of reflection: <strong>when a mirror rotates by angle \(\alpha\), the reflected beam rotates by \(2\alpha\)</strong>. This is why mirror ball dots move faster than you might expect — a ball spinning at 2 RPM produces dots that sweep at an angular rate equivalent to 4 RPM relative to the ball's rotation.</p>
      <p>The proof is straightforward. If the normal rotates from \(\hat{n}\) to \(\hat{n}'\) (a rotation of \(\alpha\)), the change in reflection angle is:</p>
      $$\Delta\theta_R = 2\alpha$$
      <p>This amplification is what gives mirror balls their dynamic, energetic feel. Even a slowly spinning ball produces fast-moving dots, especially at higher latitudes where the facets have more angular velocity relative to the spotlight.</p>

      <h3>5. Why Dots Twinkle</h3>
      <p>Real mirror ball dots shimmer and flicker. Several effects contribute:</p>
      <p><strong>Surface imperfections.</strong> The mirror tiles aren't perfectly flat — they have slight curvature from being pressed onto the sphere, and the adhesive creates minor warping. These imperfections cause each facet's effective normal to fluctuate slightly as the ball rotates, making the reflected dot wobble and change intensity.</p>
      <p><strong>Facet edges.</strong> As the ball rotates, a facet transitions from facing the spotlight to facing away. Near the boundary (when \(\hat{L} \cdot \hat{n} \approx 0\)), small changes in angle produce large changes in brightness, creating a rapid on/off flash.</p>
      <p><strong>Specular falloff.</strong> The intensity of the reflected dot depends on \((\hat{L} \cdot \hat{n})^k\) — a power-law falloff that concentrates brightness on facets that are nearly perfectly aligned with the light source. Most facets produce dim reflections; a few produce bright flashes.</p>
      <p>In the simulation, we model this with a shimmer term: a sinusoidal perturbation to each facet's normal vector, with random phase offsets per facet, producing the characteristic twinkling effect.</p>

      <h3>6. Volumetric Beams (the "God Rays")</h3>
      <p>In a hazy or smoky room, you can see the actual beams of light connecting the ball to the dots on the walls. This is Tyndall scattering (or Mie scattering for larger particles): the light beam illuminates suspended particles in the air, making the beam path visible.</p>
      <p>The beam from each facet follows the reflected ray direction \(\hat{R}\), originating at the facet's position on the ball's surface. The visibility of the beam depends on:</p>
      <ul>
        <li><strong>Particle density</strong>: more haze = more visible beams</li>
        <li><strong>Beam intensity</strong>: brighter reflections produce more visible beams</li>
        <li><strong>Viewing angle</strong>: beams are brightest when viewed from the side (90° to the beam), due to the angular dependence of Mie scattering</li>
      </ul>
      <p>In the simulation, we approximate this with semi-transparent triangular gradients emanating from the ball center, rotating with the ball. It's a visual approximation rather than a physical simulation, but captures the aesthetic effect.</p>

      <h3>7. From Physics to Pixels</h3>
      <p>The simulation maps the 3D reflected ray \(\hat{R}\) to 2D screen coordinates using a spherical projection:</p>
      $$x_{\text{screen}} = \frac{W}{2} + \frac{\text{atan2}(R_z, R_x)}{\pi} \cdot \frac{W}{2}$$
      $$y_{\text{screen}} = \frac{H}{2} - \frac{\arcsin(R_y)}{\pi/2} \cdot \frac{H}{2}$$
      <p>This wraps the full sphere of possible reflection directions onto the rectangular screen, with the forward direction (\(+z\)) centered. It's an equirectangular projection — the same mapping used for panoramic photos and environment maps.</p>
      <p>Each dot is rendered as a radial gradient with two components:</p>
      <ul>
        <li>A <strong>bright core</strong> with radius proportional to \((\hat{L} \cdot \hat{n})^{1.7}\), simulating the concentrated specular reflection</li>
        <li>A <strong>soft halo</strong> with larger radius, simulating bloom and atmospheric scattering</li>
      </ul>
      <p>The color shifts toward white at high intensity, simulating photographic overexposure — the same reason bright lights look white regardless of their actual color.</p>
      <p><em>The full simulation runs in real-time using Canvas 2D, with no WebGL or external dependencies. All physics calculations happen on the CPU at 60 fps for ~500 facets.</em></p>
    </div>
  </div>
</div>
<script>
// ── Tweakable Constants ──────────────────────────────────────────────────────
const ROTATION_RPM      = 2.0;    // Ball spin speed (RPM)
const INTENSITY         = 1.3;    // Global brightness multiplier
const FACET_ROWS        = 22;     // Mirror rows pole-to-pole
const FACETS_AT_EQUATOR = 32;     // Tiles at widest row
const DOT_RADIUS        = 2.4;    // Base dot size (px at 900px viewport)
const DOT_SHARPNESS     = 0.8;    // 0 = soft gaussian, 1 = crisp
const SHIMMER           = 0.35;   // Twinkle intensity
const SHIMMER_SPEED     = 3.0;    // Twinkle oscillation rate (Hz)
const BEAM_OPACITY      = 0.06;   // Volumetric ray visibility
const BEAM_COUNT        = 12;     // Number of light rays
const GLOW_STRENGTH     = 0.35;   // Center ball glow intensity
const LIGHT_SMOOTHING   = 0.08;   // Mouse-to-light response lag (0–1)
const LIGHT_R = 255, LIGHT_G = 30, LIGHT_B = 20; // Pinspot color

// ── Canvas Setup ─────────────────────────────────────────────────────────────
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W, H, scale;

function resize() {
  const dpr = Math.min(devicePixelRatio || 1, 2);
  W = innerWidth; H = innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  scale = H / 900;
}
resize();
addEventListener('resize', resize);

// ── Facet Generation ─────────────────────────────────────────────────────────
// Spherical coords, brick-lay stagger, proportional columns per row
const facets = [];
for (let row = 0; row < FACET_ROWS; row++) {
  const phi = Math.PI * (0.06 + 0.88 * (row + 0.5) / FACET_ROWS);
  const sinPhi = Math.sin(phi);
  const cols = Math.max(4, Math.round(FACETS_AT_EQUATOR * sinPhi));
  const stagger = (row & 1) * 0.5 / cols;
  for (let col = 0; col < cols; col++) {
    facets.push({
      theta: 2 * Math.PI * (col / cols + stagger),
      phi,
      phase: Math.random() * Math.PI * 2,
      size: 0.7 + Math.random() * 0.6
    });
  }
}

// ── State ────────────────────────────────────────────────────────────────────
const state = {
  rpm: ROTATION_RPM,
  paused: false,
  rotation: 0,
  modalOpen: false,
  helpVisible: true,
  mouseActive: false,
  mouseX: 0, mouseY: 0,
  lx: 0, ly: -0.5, lz: 0.6,
  tlx: 0, tly: -0.5, tlz: 0.6,
  lastTime: 0
};

// Reusable vectors (Float64Array for precision)
const N = new Float64Array(3);
const L = new Float64Array(3);
const R = new Float64Array(3);

// ── Interaction ──────────────────────────────────────────────────────────────
addEventListener('mousemove', e => {
  state.mouseX = e.clientX; state.mouseY = e.clientY; state.mouseActive = true;
  state.tlx = (e.clientX / W) * 2 - 1;
  state.tly = -((e.clientY / H) * 2 - 1);
  state.tlz = 0.6;
});
// Touch: 1 finger = light angle, 2 fingers = speed, double-tap = pause
let lastTouchY = 0;
let lastTapTime = 0;
addEventListener('touchstart', e => {
  if (e.touches.length === 2) {
    lastTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
  }
  if (e.touches.length === 1) {
    const now = Date.now();
    if (now - lastTapTime < 300) togglePause();
    lastTapTime = now;
  }
}, { passive: true });
addEventListener('touchmove', e => {
  if (state.modalOpen) return; // let modal scroll natively
  e.preventDefault();
  if (e.touches.length === 1) {
    const t = e.touches[0];
    state.mouseX = t.clientX; state.mouseY = t.clientY; state.mouseActive = true;
    state.tlx = (t.clientX / W) * 2 - 1;
    state.tly = -((t.clientY / H) * 2 - 1);
    state.tlz = 0.6;
  } else if (e.touches.length === 2) {
    const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    const dy = lastTouchY - midY;
    state.rpm = Math.max(0.1, Math.min(8.0, state.rpm + dy * 0.01));
    lastTouchY = midY;
  }
}, { passive: false });
addEventListener('wheel', e => {
  state.rpm = Math.max(0.1, Math.min(8.0, state.rpm + e.deltaY * 0.002));
});
canvas.addEventListener('click', () => togglePause());

// ── Modal & Help ────────────────────────────────────────────────────────────
const helpPill = document.getElementById('help-pill');
const backdrop = document.getElementById('modal-backdrop');
const modalPanel = document.getElementById('modal-panel');

function openModal() {
  state.modalOpen = true;
  backdrop.classList.add('open');
  document.body.style.cursor = 'auto';
  modalPanel.querySelector('.close').focus();
}

function closeModal() {
  state.modalOpen = false;
  backdrop.classList.remove('open');
  document.body.style.cursor = 'none';
}

function toggleHelp() {
  state.helpVisible = !state.helpVisible;
  helpPill.classList.toggle('hidden', !state.helpVisible);
}

function togglePause() {
  state.paused = !state.paused;
  document.getElementById('pauseLabel').style.display = state.paused ? 'block' : 'none';
}

// Modal triggers
modalPanel.querySelector('.close').addEventListener('click', closeModal);
backdrop.addEventListener('click', e => {
  if (e.target === backdrop) closeModal();
});

// ── Keyboard ────────────────────────────────────────────────────────────────
addEventListener('keydown', e => {
  const tag = e.target.tagName;
  if (tag === 'INPUT' || tag === 'TEXTAREA' || e.target.isContentEditable) return;

  switch (e.code) {
    case 'Space':
      e.preventDefault();
      togglePause();
      break;
    // Light angle: arrows + hjkl (vim)
    case 'ArrowUp': case 'KeyK':
      e.preventDefault();
      state.tly = Math.min(1, state.tly + 0.05);
      break;
    case 'ArrowDown': case 'KeyJ':
      e.preventDefault();
      state.tly = Math.max(-1, state.tly - 0.05);
      break;
    case 'KeyH':
      // h = light left (vim), but also toggle help — use shift for help
      e.preventDefault();
      state.tlx = Math.max(-1, state.tlx - 0.05);
      break;
    case 'KeyL':
      e.preventDefault();
      state.tlx = Math.min(1, state.tlx + 0.05);
      break;
    // Speed: arrows left/right, ; ], [ (vim-adjacent)
    case 'ArrowLeft': case 'BracketLeft':
      e.preventDefault();
      state.rpm = Math.max(0.1, state.rpm - 0.3);
      break;
    case 'ArrowRight': case 'Semicolon': case 'BracketRight':
      e.preventDefault();
      state.rpm = Math.min(8.0, state.rpm + 0.3);
      break;
    case 'KeyM':
      e.preventDefault();
      openModal();
      break;
    case 'Escape':
      if (state.modalOpen) { e.preventDefault(); closeModal(); }
      break;
    default:
      // ? = toggle help (Shift+/ on US layout)
      if (e.key === '?') { e.preventDefault(); toggleHelp(); }
      break;
  }
});

// ── Render Loop ──────────────────────────────────────────────────────────────
function frame(time) {
  requestAnimationFrame(frame);
  const dt = state.lastTime ? (time - state.lastTime) / 1000 : 0;
  state.lastTime = time;
  if (!state.paused) state.rotation += state.rpm * (2 * Math.PI / 60) * dt;

  // Smooth light direction toward target
  state.lx += (state.tlx - state.lx) * LIGHT_SMOOTHING;
  state.ly += (state.tly - state.ly) * LIGHT_SMOOTHING;
  state.lz += (state.tlz - state.lz) * LIGHT_SMOOTHING;
  const lLen = Math.sqrt(state.lx * state.lx + state.ly * state.ly + state.lz * state.lz);
  L[0] = state.lx / lLen; L[1] = state.ly / lLen; L[2] = state.lz / lLen;

  const cx = W / 2, cy = H / 2;
  const t = time * 0.001;

  // ── Layer 1: Background ────────────────────────────────────────────────────
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = 'rgb(2,1,5)';
  ctx.fillRect(0, 0, W, H);

  // ── Layer 2: Cursor glow (spotlight source) ────────────────────────────────
  if (state.mouseActive) {
    const r = 180 * scale;
    const cg = ctx.createRadialGradient(state.mouseX, state.mouseY, 0, state.mouseX, state.mouseY, r);
    cg.addColorStop(0, `rgba(${LIGHT_R},${LIGHT_G},${LIGHT_B},0.10)`);
    cg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = cg;
    ctx.fillRect(state.mouseX - r, state.mouseY - r, r * 2, r * 2);
  }

  // ── Layer 3: Center glow (ambient scatter from ball body) ──────────────────
  const gr = 350 * scale;
  const gg = ctx.createRadialGradient(cx, cy, 0, cx, cy, gr);
  gg.addColorStop(0, `rgba(${LIGHT_R},${LIGHT_G},${LIGHT_B},${(0.08 * GLOW_STRENGTH).toFixed(3)})`);
  gg.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = gg;
  ctx.fillRect(cx - gr, cy - gr, gr * 2, gr * 2);

  // ── Layer 4: Volumetric beams ──────────────────────────────────────────────
  ctx.globalCompositeOperation = 'lighter';
  const beamLen = Math.max(W, H) * 0.9;
  for (let i = 0; i < BEAM_COUNT; i++) {
    const base = (i / BEAM_COUNT) * Math.PI * 2 + state.rotation * 0.5;
    const wobble = Math.sin(t + i * 2.1) * 0.04;
    const angle = base + wobble;
    const spread = 0.035;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(angle - spread) * beamLen, cy + Math.sin(angle - spread) * beamLen);
    ctx.lineTo(cx + Math.cos(angle + spread) * beamLen, cy + Math.sin(angle + spread) * beamLen);
    ctx.closePath();
    const bg = ctx.createLinearGradient(cx, cy,
      cx + Math.cos(angle) * beamLen, cy + Math.sin(angle) * beamLen);
    bg.addColorStop(0, `rgba(${LIGHT_R},${LIGHT_G},${LIGHT_B},${BEAM_OPACITY})`);
    bg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = bg;
    ctx.fill();
  }

  // ── Layer 5: Reflected light dots ──────────────────────────────────────────
  for (let i = 0; i < facets.length; i++) {
    const f = facets[i];
    const theta = f.theta + state.rotation;
    const sinPhi = Math.sin(f.phi), cosPhi = Math.cos(f.phi);

    // Facet normal (Y-axis rotation baked into theta)
    N[0] = sinPhi * Math.cos(theta);
    N[1] = cosPhi;
    N[2] = sinPhi * Math.sin(theta);

    // Shimmer: sinusoidal perturbation to normal (micro-vibration / surface imperfection)
    const sh = SHIMMER * Math.sin(t * SHIMMER_SPEED + f.phase);
    N[0] += sh * 0.03 * Math.sin(f.phase + t * 1.7);
    N[1] += sh * 0.03 * Math.cos(f.phase + t * 2.3);
    N[2] += sh * 0.03 * Math.sin(f.phase * 1.3 + t * 1.1);
    const nLen = Math.sqrt(N[0] * N[0] + N[1] * N[1] + N[2] * N[2]);
    N[0] /= nLen; N[1] /= nLen; N[2] /= nLen;

    // Back-face culling: skip facets not facing the light
    const NdotNegL = -(N[0] * L[0] + N[1] * L[1] + N[2] * L[2]);
    if (NdotNegL < 0.01) continue;

    // Reflection: R = L - 2(L·N)N
    const LdotN = L[0] * N[0] + L[1] * N[1] + L[2] * N[2];
    R[0] = L[0] - 2 * LdotN * N[0];
    R[1] = L[1] - 2 * LdotN * N[1];
    R[2] = L[2] - 2 * LdotN * N[2];

    // Spherical unwrap → screen coords
    const az = Math.atan2(R[2], R[0]);
    const el = Math.asin(Math.max(-1, Math.min(1, R[1])));
    const sx = cx + (az / Math.PI) * cx;
    const sy = cy - (el / (Math.PI * 0.5)) * cy;

    // Specular falloff
    const brightness = Math.pow(NdotNegL, 1.7) * INTENSITY;

    // Color: bloom bright dots toward white (overexposure simulation)
    const bloom = Math.min(1, brightness);
    const cr = LIGHT_R + (255 - LIGHT_R) * bloom;
    const cg = LIGHT_G + (255 - LIGHT_G) * bloom;
    const cb = LIGHT_B + (255 - LIGHT_B) * bloom;

    const baseR = DOT_RADIUS * scale * f.size;
    const coreR = Math.max(0.5, baseR * (0.3 + 0.7 * brightness));
    const haloR = coreR * (2.5 + 2.5 * (1 - DOT_SHARPNESS));

    // Outer halo
    if (haloR > 0.5) {
      const haloA = Math.min(1, 0.2 * brightness);
      const hg = ctx.createRadialGradient(sx, sy, 0, sx, sy, haloR);
      hg.addColorStop(0, `rgba(${cr|0},${cg|0},${cb|0},${haloA.toFixed(3)})`);
      hg.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = hg;
      ctx.beginPath();
      ctx.arc(sx, sy, haloR, 0, Math.PI * 2);
      ctx.fill();
    }

    // Crisp bright core
    ctx.fillStyle = `rgba(${cr|0},${cg|0},${cb|0},${Math.min(1, brightness * 0.9).toFixed(3)})`;
    ctx.beginPath();
    ctx.arc(sx, sy, coreR, 0, Math.PI * 2);
    ctx.fill();
  }

  // Reset compositing
  ctx.globalCompositeOperation = 'source-over';
}
requestAnimationFrame(frame);
</script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
<script>
renderMathInElement(document.querySelector('.modal-body'), {
  delimiters: [
    { left: '$$', right: '$$', display: true },
    { left: '\\(', right: '\\)', display: false }
  ],
  throwOnError: false
});
</script>
</body>
</html>
